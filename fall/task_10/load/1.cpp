#include <iostream>
#include <conio.h>
#include <math.h>
#include "CTimer.h"
//нагрузочное тестирование— определение времени отклика программно-технической системы или устройства в ответ на внешний запрос

using namespace std;
int main(void)
{
	CTimer Time;
    Time.Start();
        const int n=9;//размер исходного массива
        const int n1=5;//размер левого массива(делим массив на не равноразмерные части)
        const int n2=4;//размер правого массива
        int a[n]={2, 5, 1, 2, 3, 4, 7, 7, 6};//исходный массив
        int a1[n1];//левый и правый массивы-части исходного(их размеры)
        int a2[n2];
        
//копирование левой части исходного массива в массив 1
        for(int i=0; i<n1; i++)
        {
                a1[i]=a[i];
        }
        int j;
        int i;
//копирование правой части исходного массива в массив 2
        for(i=0, j=n1; i<n2, j<n; i++, j++)
        {
                        a2[i]=a[j];
        }
//находим максимумы в массиве 1 и 2
        int max1=0;//начальное значение максимума для первого массива
        int i_max1=0;
        for(int i=0; i<n1; i++)
        {
                if(a1[i]>max1)
                {
                        max1=a1[i];
                        i_max1=i;//индекс максимального элемента в левой части
                }
        }
        int max2=0;//то же для второго массива
        int i_max2=0;
        for(int i=0; i<n2; i++)
        {
                if(a2[i]>max2)
                {
                        max2=a2[i];
                        i_max1=i;//индекс максимального элемента в правой части
                }
        }
        //находим максимум во ВСЕМ массиве, чтобы определить его индекс(относительно исходного массива)
        int max=0, i_max=0;
        for(int i=1; i<=n; i++)
        {
                if(a[i]>max)
                {
                        max=a[i];
                        i_max=i;
                }
        }

        //находим из двух максимумов тот, что меньше и присваиваем ему статус "рабочего значения"(т.к выше этой стены вода точно не поднимется)
        int k, r, r_max, k_max;
        if(max1>max2)
        {
                r=max2;//"рабочее значение"
                k=max1;//самая высока стена, после нее считать количество воды не имеет смысла
                r_max=i_max2;//их индексы, необходимы для циклов for
                k_max=i_max;
                
        }
        else
        {
                r=max1;//то же самое если max1<max2
                k=max2;
                r_max=i_max1;
                k_max=i_max;
                
        }
        /*через цикл считаем объем воды в лужах между стен. Аналитически это можно сделать по ф-ле (r-1)+(r-2)+(r-3)+(r-4)=volume( где числа 1, 2, 3, 4
        это элементы массива, расположенные в исходном массиве между максимальными элементами правой и левой части(т.е в нашем случае между 5 и 7)).
        согласно ф-ле, мы берем каждый столбик жидкости по отдельности и кол-во жидкости в нем будет равно: максимальная высота(r  в нашем случае равно5)
        минус высота столбца)*/
        int volume=0;//начальное значение объема
        for(int i=r_max; i<k_max; i++)//проходим по элементам исходного значения 
        {
                volume+=(r-a[i]);
        }
        cout<<"Volume of water in this example = "<<volume<<endl;
		Time.End();
    std::cout << Time.GetTimeInSeconds() 
          << " seconds" << std::endl;
        getch ();
}