#include <iostream>
#include <conio.h>
#include <windows.h>
#include <fstream>
using namespace std;
// Вспомогательный класс, описывающий один узел:
class TreeNode
{
	friend class Tree; /* Основной класс должен быть объявлен дружественным, чтобы он имел доступ к элементам узла */  
	// Элементы данных:
	int data;
	
	public:
	TreeNode* lPtr;
	TreeNode* rPtr;
	// Конструктор:
	TreeNode(int d)
	{data = d; lPtr = NULL; rPtr = NULL;}
};

// Основной класс:
class Tree
{
	
// закрытые функции:
	
	void Add(TreeNode*&,int); // добавляет новый элемент
	void preOrder(TreeNode*);  // Обход в ширину
	void inOrder(TreeNode*); // Последовательный обход
	void postOrder(TreeNode*); // Обратный обход
	
	public:
	TreeNode* rootPtr; // указатель на корневой узел (элемент данных)
	// Конструктор:
	Tree() {rootPtr = NULL;}
	// открытые функции, которые будет использовать главная программа:	
	void Add( int);
	void Tree::Out();
	void Tree::Out (TreeNode *w,int l);


};

// Определение функций:
//Функция, которая добавляет узел к дереву:
void Tree :: Add(int m)
{
	Add(rootPtr, m);
/* Здесь и далее перегрузка функций требуется, поскольку главная программа не имеет доступа к корневому узлу дерева, поэтому единственное назначение этого вызова функции Add() – передать адрес корневого узла. */
}
/* Основная функция, которая обходит дерево и привязывает новый узел к дереву: */
void Tree :: Add(TreeNode*& ptr, int m)
{
	if (!ptr) 
/* Если текущий указатель равен 0, к нему подвязываем новый узел
 или создаем корневой */
		ptr = new TreeNode(m); 
/* благодаря тому, что параметр ptr объявлен как ссылка на указатель, уста-навливается значение указателя на корневой узел или изменяется значение указателя в том узле, к которому привязывается новый */
	else
	{
		
		if (m < ptr->data) Add(ptr->lPtr, m); 
// если новый элемент меньше значения в текущем узле, идем налево 
		else if (m > ptr->data) Add(ptr->rPtr, m);
// в противном случае - направо
// если встречается повторяющееся значение, то оно  игнорируется, благодаря этому все элементы дерева будут различны 
	}
}
void Tree::Out()
{
	Out(rootPtr, 0);
}
void Tree::Out (TreeNode *w,int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
  int i;
 
  if  (w!=NULL)
  { Out(((*w).rPtr),l+1);
    for  (i=1; i<=l; i++) cout<<"   ";
    cout<<(*w).data<<endl;
    Out(((*w).lPtr),l+1); }
}